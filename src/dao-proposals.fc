;; Proposals type

;; proof index:uint256 owner_address:MsgAddress body:^X with_content:(## 1) content:with_content?^Cell = Proof X

;; text$_ ref:^Cell = Text

;; candidate$_ id:uint32 address:MsgAddress bio:Text = Candidate

;; add_member_proposal$0001 candidate:Candidate description:Text = Proposal
;; remove_member_proposal$0010 candidate_id:uint32 description:Text = Proposal
;; generic_proposal$0011 topic:Text description:Text = Proposal

;; cast_nay$0 proposal_id:uint4 = CastVote
;; cast_yay$1 proposal_id:uint4 = CastVote

;; state$_ owner_id:unit32 sbt_item_code:^Cell nft_collection_address:MsgAddress proposals:HashMapE 3 ProposalState = State
;; votes voted:uint256 votes:uint256 = Votes
;; proposal_state$_ creator_id:uint32 expiration_date:uint64 votes:^Votes body:^Proposal = ProposalState

;; ievent_check_proof$0001 expiration_date:uint64 body:^Proposal = IEvent
;; ievent_create_proposal$0010 expiration_date:uint64 body:^Proposal = IEvent
;; ievent_vote$0011 vote:CastVote = IEvent
;; ievent_execute_decision$0100 proposal_id:uin4 = IEvent
;; event$_ body:(Proof IEvent) = Event


global int storage::owner_id;
global cell storage::proposals;

const PROPOSALS_BITS = 4;
const MEMBER_ID_BITS = 32;
const TS_BITS = 64;

const DICT_ERROR = 10;
const INVALID_ACTION_ERROR = 34;
const DOUBLE_VOTE_ERROR = 1001;
const UNKNOWN_PROPOSAL_ERROR = 1002;
const NOT_ENOUGH_SPACE_FOR_PROPOSALS_ERROR = 1003;
const NOT_ENOUGH_REFS_GENERIC_PROPOSAL_ERROR = 1004;
const TOO_MANY_PROPOSALS_FROM_USER = 1005;
const PROPOSAL_IS_NOT_COMPLETE_YET = 1006;

const PROPOSAL_TYPE_ADD_MEMBER = 1;
const PROPOSAL_TYPE_REMOVE_MEMBER = 2;
const PROPOSAL_TYPE_GENERIC = 3;

const MAX_PROPOSALS_FROM_USER = 1;

const OP_CHECK_PROOF = 1;
const OP_CREATE_PROPOSAL = 2;
const OP_CAST_VOTE = 3;
const OP_EXECUTE_DECISION = 4;

slice storage_get_state() method_id {
  return get_data().begin_parse();
}

(int, cell, slice, cell) storate_get_dao_state() {
  var state = storage_get_state();
  return (state~load_uint(MEMBER_ID_BITS), state~load_ref(), state~load_msg_addr(), state~load_dict());
}

int storage_get_owner_id() method_id {
  var (owner_id, _, _, _) = storate_get_dao_state();
  return owner_id;
}

cell storage_get_proposals() {
  var (_, _, _, proposals) = storate_get_dao_state();
  return proposals;
}

(int, int, cell, cell) storage_get_proposal(int proposal_id) method_id {
  var proposals = storage_get_proposals();
  var (proposal, success) = proposals.udict_get?(PROPOSALS_BITS, proposal_id);
  throw_unless(DICT_ERROR, success);
  var creator_id = proposal~load_uint(MEMBER_ID_BITS);
  var expiration_date = proposal~load_uint(TS_BITS);
  var votes = proposal~load_ref();
  var body = proposal~load_ref();
  return (creator_id, expiration_date, votes, body);
}

(int, int) storage_get_votes(cell votes) {
  var votes_slice = votes.begin_parse();
  var voted = votes_slice~load_uint(256);
  var votes_for = votes_slice~load_uint(256);
  return (voted, votes_for);
}

int storage_count_votes(cell votes, int vote_for) {
  var (voted, votes_for) = storage_get_votes(votes);

  var bit_votes = 0;
  if (vote_for) {
    bit_votes = voted & votes_for;
  } else {
    bit_votes = voted ^ votes_for;
  }
  var count = 0;
  while(bit_votes) {
    bit_votes &= (bit_votes - 1);
    count += 1;
  }
  return count;
}

int storage_count_proposal_yays(int proposal_id) method_id {
  var (_, _, votes, _) = storage_get_proposal(proposal_id);
  return storage_count_votes(votes, true);
}

int storage_count_proposal_nays(int proposal_id) method_id {
  var (_, _, votes, _) = storage_get_proposal(proposal_id);
  return storage_count_votes(votes, false);
}

int storage_get_proposal_expiration_date(int proposal_id) method_id {
  var (_, date, _, _) = storage_get_proposal(proposal_id);
  return date;
}

slice storage_get_proposal_info(int proposal_id) method_id {
  var  (_, _, _, proposal) = storage_get_proposal(proposal_id);
  return proposal.begin_parse();
}

() storage_set_state(int owner_id, cell sbt_item_code, slice nft_collection_address, cell proposals) impure {
  set_data(begin_cell()
    .store_uint(owner_id, MEMBER_ID_BITS)
    .store_ref(sbt_item_code)
    .store_slice(nft_collection_address)
    .store_dict(proposals).end_cell());
}

() storage_set_proposals(cell proposals) impure {
  var (owner_id, code, nft, _) = storate_get_dao_state();
  storage_set_state(owner_id, code, nft, proposals);
}

() storage_set_proposal(int proposal_id, int member_id, int expiration_date, cell votes, cell body) impure {
  var proposals = storage_get_proposals();
  var tproposal = begin_cell()
    .store_uint(member_id, MEMBER_ID_BITS)
    .store_uint(expiration_date, TS_BITS)
    .store_ref(votes)
    .store_ref(body)
    .end_cell().begin_parse();
  storage_set_proposals(proposals.udict_set(PROPOSALS_BITS, proposal_id, tproposal));
}

cell storage_update_votes(int member_id, cell votes, int vote_for) {
  var (voted, votes_for) = storage_get_votes(votes);
  var member_vote = 1 << member_id;
  throw_if(DOUBLE_VOTE_ERROR, member_vote & voted);
  voted |= member_vote;
  if (vote_for) {
    votes_for |= member_vote;
  }
  return begin_cell()
    .store_uint(voted, 256)
    .store_uint(votes_for, 256)
    .end_cell();
}

() storage_cast_vote(int proposal_id, int member_id, int vote) impure {
  var (creator_id, expiration_date, votes, body) = storage_get_proposal(proposal_id);
  storage_set_proposal(proposal_id, creator_id, expiration_date, storage_update_votes(member_id, votes, vote), body);
}

(int, slice, cell) check_proof(slice sender_address, slice msg) impure {
  var member_id = msg~load_uint(256);
  var owner_address = msg~load_msg_addr();
  var body = msg~load_ref();
  var (_, sbt_item_code, nft_collection_address, _) = storate_get_dao_state();
  var expected_address = calculate_nft_item_address_init(member_id, sbt_item_code, nft_collection_address);
  ;; this is our check proof, relying on sender_address
  throw_unless(INVALID_ACTION_ERROR, equal_slices(expected_address, sender_address));
  return (member_id, owner_address, body);
}

() cast_vote(int member_id, slice data) impure {
  var vote = data~load_uint(1);
  var proposal_id = data~load_uint(PROPOSALS_BITS);
  if (vote == 1) {
    storage_cast_vote(proposal_id, member_id, true);
  } else {
    storage_cast_vote(proposal_id, member_id, false);
  }
}

cell parse_text(slice data) {
  return data~load_ref();
}

[int, slice, cell] parse_candidate(data) {
  var tg_id = data~load_uint(32);
  var address = data~load_msg_addr();
  var bio = parse_text(data);
  return [tg_id, address, bio];
}

([int, slice, cell], cell) parse_add_member_proposal(slice data) impure {
  var candidate = parse_candidate(data);
  var text = parse_text(data);
  return (candidate, text);
}

[int, cell] parse_remove_member_proposal(slice data) impure {
  var member_id = data~load_uint(32);
  var description = parse_text(data);
  return [member_id, description];
}

int parse_proposal_type(slice data) impure {
  var tp = data~load_uint(4);
  if (tp == PROPOSAL_TYPE_ADD_MEMBER) {
    return tp;
  }

  if (tp == PROPOSAL_TYPE_REMOVE_MEMBER) {
    return tp;
  }
  if (tp == PROPOSAL_TYPE_GENERIC) {
    return tp;
  }
  throw(UNKNOWN_PROPOSAL_ERROR);
  return 0;
}

[cell, cell] parse_generic_proposal(slice data) impure {
  throw_unless(NOT_ENOUGH_REFS_GENERIC_PROPOSAL_ERROR, data.slice_refs() == 2);
  var topic = parse_text(data);
  var description = parse_text(data);
  return [topic, description];
}

() validate_proposal(slice data) impure {
  var tp = parse_proposal_type(data);
  if (tp == PROPOSAL_TYPE_ADD_MEMBER) {
    ;; should we check for duplicates?
    parse_add_member_proposal(data);
  }

  if (tp == PROPOSAL_TYPE_REMOVE_MEMBER) {
    ;; should we check that person exists?
    parse_remove_member_proposal(data);
  }

  if (tp == PROPOSAL_TYPE_GENERIC) {
    parse_generic_proposal(data);
  }
}

cell create_votes_storage() {
  return begin_cell()
    .store_uint(0, 256)
    .store_uint(0, 256)
    .end_cell();
}

int select_new_proposal_id() method_id {
  var proposals = storage_get_proposals();
  var (cur_key, _, success) = proposals.udict_get_min?(PROPOSALS_BITS);
  if (~ success) {
    ;; this means dict is empty
    return 0;
  }
  if (cur_key > 0) {
    ;; there are some proposals, but
    return cur_key - 1;
  }
  do {
    var (key, _, success_next) = proposals.udict_get_next?(PROPOSALS_BITS, cur_key);
    if (success_next) {
      if (key - cur_key > 1) {
        ;; there is a gap between those keys, select previous value
        return key - 1;
      }
      cur_key = key;
    }
  } until (~ success_next);
  if (cur_key < (1 << PROPOSALS_BITS) - 1) {
    ;; the max key is less than max allowed value, so just take next
    return cur_key + 1;
  }
  throw(NOT_ENOUGH_SPACE_FOR_PROPOSALS_ERROR);
  return -1;
}

int storage_count_user_proposals(int member_id) {
  var proposals = storage_get_proposals();
  var count = 0;
  var (key, proposal, success) = proposals.udict_get_min?(PROPOSALS_BITS);
  do {
    if (success) {
      var creator_id = proposal~load_uint(MEMBER_ID_BITS);
      if (creator_id == member_id) {
        count += 1;
      }
      (key, proposal, success) = proposals.udict_get_next?(PROPOSALS_BITS, key);
    }
  } until (~ success);
  return count;
}

() create_proposal(int member_id, slice data) impure {
  var expiration_date = data~load_uint(TS_BITS);
  var body = data~load_ref();
  validate_proposal(body.begin_parse());
  var proposal_id = select_new_proposal_id();
  throw_if(TOO_MANY_PROPOSALS_FROM_USER, storage_count_user_proposals(member_id) >= MAX_PROPOSALS_FROM_USER);
  storage_set_proposal(proposal_id, member_id, expiration_date, create_votes_storage(), body);
}

() execute_decision(int member_id, slice data) impure {
  var proposal_id = data~load_uint(PROPOSALS_BITS);
  var (creator_id, expiration_date, votes, body) = storage_get_proposal(proposal_id);
  var time = now();
  throw_if(PROPOSAL_IS_NOT_COMPLETE_YET, time < expiration_date);
  ;; TODO: how to track current dao members, if sbt item is destroyed we have no way of knowing
  ;; we can store counter, but it won't account of destroyed sbt items (by user or system)
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
  if (in_msg_body.slice_empty?()) { ;; ignore empty messages
    return ();
  }

  slice cs = in_msg_full.begin_parse();
  int flags = cs~load_uint(4);
  slice sender_address = cs~load_msg_addr();

  var (member_id, owner_address, operation_cell) = check_proof(sender_address, in_msg_body);
  var op_slice = operation_cell.begin_parse();
  var operation = op_slice~load_uint(4);
  if (operation == OP_CHECK_PROOF) {
    return ();
  }

  if (operation == OP_CAST_VOTE) {
    cast_vote(member_id, op_slice);
    return ();
  }

  if (operation == OP_CREATE_PROPOSAL) {
    create_proposal(member_id, op_slice);
    return ();
  }

  if (operation == OP_EXECUTE_DECISION) {
    execute_decision(member_id, op_slice);
    return ();
  }

  throw(1000);
}
