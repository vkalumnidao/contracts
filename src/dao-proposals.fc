;; Proposals type

;; proof index:uint256 owner_address:MsgAddress body:^X with_content:(## 1) content:with_content?^Cell = Proof X

;; text$_ ref:^Cell = Text

;; candidate$_ id:uint32 bio:Text = Candidate

;; add_member_proposal$0001 candidate:Candidate description:Text = Proposal
;; remove_member_proposal$0010 candidate_id:uint32 description:Text = Proposal
;; generic_proposal$0011 topic:Text description:Text = Proposal

;; cast_yay$0 proposal_id:uint8 = CastVote
;; cast_nay$1 proposal_id:uint8 = CastVote

;; state$_ owner_id:unit32 sbt_item_code:^Cell nft_collection_address:MsgAddress proposals:HashMapE 3 ProposalState = State
;; proposal_state$_ expiration_date:uint64 yay:(HashmapE 32 True) nay:(HashmapE 32 True) body:^Proposal = ProposalState

;; ievent_create_proposal$0001 expiration_date:uint64 body:^Proposal = IEvent
;; ievent_vote$0010 vote:CastVote = IEvent
;; ievent_update_code$0011 code:^Cell= IEvent
;; event$_ body:(Proof IEvent) = Event


global int storage::owner_id;
global cell storage::proposals;

const PROPOSALS_BITS = 3;
const MEMBER_ID_BITS = 32;
const TS_BITS = 64;

const DICT_ERROR = 10;
const INVALID_ACTION_ERROR = 34;

const OP_CHECK_PROOF = 1;

slice storage_get_state() method_id {
  return get_data().begin_parse();
}

(int, cell, slice, cell) storate_get_dao_state() {
  var state = storage_get_state();
  return (state~load_uint(MEMBER_ID_BITS), state~load_ref(), state~load_msg_addr(), state~load_dict());
}

int storage_get_owner_id() method_id {
  var (owner_id, _, _, _) = storate_get_dao_state();
  return owner_id;
}

cell storage_get_proposals() {
  var (_, _, _, proposals) = storate_get_dao_state();
  return proposals;
}

(int, cell, cell, cell) storage_get_proposal(int proposal_id) {
  var proposals = storage_get_proposals();
  var (proposal, success) = proposals.udict_get?(PROPOSALS_BITS, proposal_id);
  throw_unless(DICT_ERROR, success);
  var expiration_date = proposal~load_uint(TS_BITS);
  var yay = proposal~load_dict();
  var nay = proposal~load_dict();
  var body = proposal~load_ref();
  return (expiration_date, yay, nay, body);
}

int storage_count_votes(cell votes) {
  var count = 0;
  var current_key = 0;

  if (votes.dict_empty?()) {
    return 0;
  }

  do {
    var (current_key, _, success) = votes.udict_get_next?(MEMBER_ID_BITS, current_key);
    if (success) {
      count += 1;
    }
  } until (success)
  return count;
}

int storage_count_proposal_yays(int proposal_id) method_id {
  var (_, yay, _, _) = storage_get_proposal(proposal_id);
  return storage_count_votes(yay);
}

int storage_count_proposal_nays(int proposal_id) method_id {
  var (_, _, nay, _) = storage_get_proposal(proposal_id);
  return storage_count_votes(nay);
}

int storage_get_proposal_expiration_date(int proposal_id) method_id {
  var  (date, _, _, _) = storage_get_proposal(proposal_id);
  return (date);
}

slice storage_get_proposal_info(int proposal_id) method_id {
  var  (_, _, _, proposal) = storage_get_proposal(proposal_id);
  return proposal.begin_parse();
}

(int, slice, cell) check_proof(slice sender_address, slice msg) {
  var member_id = msg~load_uint(256);
  var owner_address = msg~load_msg_addr();
  var body = msg~load_ref();
  var (_, sbt_item_code, nft_collection_address, _) = storate_get_dao_state();
  var expected_address = calculate_nft_item_address_init(member_id, sbt_item_code, nft_collection_address);
  ;; this is our check proof, relying on sender_address
  throw_unless(INVALID_ACTION_ERROR, equal_slices(expected_address, sender_address));
  return (member_id, owner_address, body);
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
  if (in_msg_body.slice_empty?()) { ;; ignore empty messages
    return ();
  }

  slice cs = in_msg_full.begin_parse();
  int flags = cs~load_uint(4);
  slice sender_address = cs~load_msg_addr();

  var (member_id, owner_address, operation_cell) = check_proof(sender_address, in_msg_body);
  var op_slice = operation_cell.begin_parse();
  var operation = op_slice~load_uint(4);
  if (operation == OP_CHECK_PROOF) {
    return ();
  }

  throw(1000);
}
